---
layout: single
title: "백준 Online Judge - #9012"
excerpt: "백준 9012번 문제풀이 과정 기록입니다."

categories : 
    - Baekjoon
tags:
    - [Cpp,Baekjoon]

date: 2025-06-25
---
<br><br>
백준 문제 중 "9012 - 괄호" 문제풀이 포스팅입니다.<br>
(참고로 필자는 자료구조와 알고리즘에 관한 지식이 없는 상태로 관련 문제들을 풀어나가는 중임을 미리 알려드립니다.)


백준 9012번은 자료구조, 문자열, 스택에 관해 공부할 수 있는 문제로 분류되어 있다. 내용은 아래와 같다.

```md
문제


괄호 문자열(Parenthesis String, PS)은 두 개의 괄호 기호인 ‘(’ 와 ‘)’ 만으로 구성되어 있는 문자열이다. 그 중에서 괄호의 모양이 바르게 구성된 문자열을 올바른 괄호 문자열(Valid PS, VPS)이라고 부른다. 한 쌍의 괄호 기호로 된 “( )” 문자열은 기본 VPS 이라고 부른다. 만일 x 가 VPS 라면 이것을 하나의 괄호에 넣은 새로운 문자열 “(x)”도 VPS 가 된다. 그리고 두 VPS x 와 y를 접합(concatenation)시킨 새로운 문자열 xy도 VPS 가 된다. 예를 들어 “(())()”와 “((()))” 는 VPS 이지만 “(()(”, “(())()))” , 그리고 “(()” 는 모두 VPS 가 아닌 문자열이다. 

여러분은 입력으로 주어진 괄호 문자열이 VPS 인지 아닌지를 판단해서 그 결과를 YES 와 NO 로 나타내어야 한다. 
```

```
입력

입력 데이터는 표준 입력을 사용한다. 입력은 T개의 테스트 데이터로 주어진다. 입력의 첫 번째 줄에는 입력 데이터의 수를 나타내는 정수 T가 주어진다. 각 테스트 데이터의 첫째 줄에는 괄호 문자열이 한 줄에 주어진다. 하나의 괄호 문자열의 길이는 2 이상 50 이하이다. 

출력

출력은 표준 출력을 사용한다. 만일 입력 괄호 문자열이 올바른 괄호 문자열(VPS)이면 “YES”, 아니면 “NO”를 한 줄에 하나씩 차례대로 출력해야 한다. 
```

문제를 직접 보고 싶으신 분들은 아래 링크를 따라가시길!<br>
☞ [백준 9012.괄호 문제 보러가기](https://www.acmicpc.net/problem/9012)

처음에 이 문제를 봤을 때 고민했던 부분은 VPS인지 아닌지에 대해 판단을 어떻게 할 것인가였다. 사실 인간의 눈에는 어떤게 VPS이고 아닌지, 한 눈에 딱 볼 수 있지 않은가?

( ( ) ) <<음 이건 VPS지 <br> 
( )( ) ) << 이건 아니고... <br>
( ( ( ) ) ( ) ( ( ) ) ) <<이건 VPS가 맞군

인간의 관점에서, 이러한 판단은 어떻게 할 수 있는가? 연습장에 직접 따라 그려 보면서 쌍을 지어보든, 아니면 눈으로 지어보든 어쨌든 괄호들끼리의 쌍을 직접 지어보면서 확인할 수 있다. 이 때 1차적으로 VPS를 판별할 수 있는 조건을 알 수 있다.

>'('기호와 ')'기호가 같은 개수만큼 존재해야 한다.

그래야 괄호의 쌍이 이루어지기 때문이다. 문제는 그 다음이었다. 괄호의 짝꿍은 서로 바로 붙어 있을 수도 있고, 안에 다른 괄호들을 둔 채로 바깥쪽을 감싸고 있을 수도 있는데, 이들이 서로 올바르게 쌍을 이루어서 VPS가 될지를 어떻게 판별하지? 또 서로 짝을 이루고 있을지언정 <br>')('<br>이런 식으로 짝을 이루는 것도 문제이다. 

![고뇌의흔적...](/uploads/4thpostimages/BJprob9012_img1.jpg)

VPS를 만족하는 괄호의 배치에 대한 조건을 여러 케이스별로 일일이 다 지정해줘야 하나? 생각하던 중 좀 더 일반적으로 적용할 수 있는 조건을 생각해냈다.

> 먼저, '('기호와')'기호가 서로 같은 수가 있는지 확인한다. 해당 조건 만족 시 입력된 괄호 문자열에서 '('기호와 ')'기호가 배치되어 있는 순서를 각각 저장하여, 모든 ')'에 대해 그보다 앞 번호에 존재하는 '('기호를 매치할 수 있다면, VPS를 만족한다.

예를 들어, 괄호 문자열 "( ( ) ) ( ) "이 들어왔다고 할 때...<br>
```
(  (  )  )  (  )
0  1  2  3  4  5
```
각 기호에 대해 다음과 같이 배열의 번호가 매겨질 것이다. 이 때 '('와(앞으로 왼쪽괄호라고 칭하겠삼) ')'(앞으로 오른쪽괄호라고 칭하겠삼)가 저장된 배열의 번호를 각각 저장하는 배열을 만든다. <br>
```
왼쪽괄호 : 0,1,4
오른쪽괄호 : 2,3,5
```
그러고 각각 왼쪽괄호와 오른쪽괄호가 저장된 배열에서 동일한 순서의 값들끼리 비교하여, 왼쪽괄호가 오른쪽괄호보다 앞 번호에 있는지 비교하는거다.

```
왼쪽괄호   오른쪽괄호

   0    <     2
   1    <     3
   4    <     5
```
따라서, 해당 예제는 VPS다.

사실, 이러한 조건이 **모든** VPS에 예외없이 적용될 수 있는 조건인지는 검증하지 못했다. 몇 가지 예제에의 적용과 "이론적으로 될 것 같은데?" 라는 생각으로 코드를 짰을 뿐...  이를 어떻게 증명할 수 있을까? 일단, 이대로 한번 코드를 짜 보자.


```cpp
int main()
{
    int trial;
    std::cin >> trial;

    for (int i = 0; i < trial; i++)
    {
        char* input = new char[50];
        std::cin >> input;
        int length = strlen(input);

        int left[50], right[50];
        int l = 0, r = 0;

        //괄호 문자열 입력받기

        for (int j = 0; j < length; j++)
        {
            if (input[j] == ')')
            {
                right[r] = j;
                r++;
            }
            else if (input[j] == '(')
            {
                left[l] = j;
                l++;
            }
        }
        //std::cout << r << std::endl;
        //std::cout << l << std::endl;

        //VPS 판독
        if (l == r)
        {
            for (int k = 0; k < l; k++)
            {
                if (right[k] > left[k])
                {
                    std::cout << "NO" << std::endl;
                    break;
                }
            }
            std::cout << "YES" << std::endl;
        }
        else
            std::cout << "NO" << std::endl;

        delete[] input;
    }
}

```
1차 코드다. 먼저 실행 횟수를 받아서 그만큼 실행이 되도록 for문을 만들었고, 그 안에 괄호 문자열을 받을 공간을 동적할당으로 지정해줬다. (사실 굳이 동적할당을 할 필요는 없었던 것 같긴 한데.) 그리고 왼쪽 괄호와 오른쪽 괄호가 있는 순서를 저장할 수 있는 int 배열도 각각 만들어주었다.

실행을 시켜보니 얼추 잘 실행되는가 싶더니...

![뭣이문젠디!](/uploads/4thpostimages/BJprob9012_whyerrorimg1.jpg)
뭣이 문젠디!!

VPS가 아닌 경우에 NO문은 잘 실행이 되나, VPS가 맞는 경우에 NO와 YES가 동시에 출력된다. <br> NO 이후 YES가 실행되는 걸 보니 if문 안의 NO가 무조건 출력되는 것 같은데...

생각해보니 오른쪽괄호가 왼쪽괄호보다 뒤에 오는 게 VPS의 조건이다. 부등호를 반대로 적었다.

```cpp
 for (int k = 0; k < l; k++)
 {
     if (right[k] < left[k])
     {
         std::cout << "NO" << std::endl;
         break;
     }
 }
```
부등호 방향 수정해주기.

또한 저 break가 문제인 것 같다. 생각해보니 break로 for문을 탈출하더라도 그 아래 코드인 YES의 출력은 무조건 거치게 되겠다. 

flag를 사용해서 VPS 판독에 대한 코드를 수정해보았다.
```cpp

...
        if (l == r)
        {
            int flag = 0;

            for (int k = 0; k < l; k++)
            {
                if (right[k] < left[k])
                {
                    std::cout << "NO" << std::endl;
                    flag++;
                    break;
                }
            }
            if(flag == 0)
                std::cout << "YES" << std::endl;
        }
        else
            std::cout << "NO" << std::endl;

        delete[] input;

...

```

코드가 조금 덕지덕지(?) 한 것 같아서 완전히 만족스럽진 않지만 일단 실행시켜보니 실행은 잘 된다.

그럼 이대로 일단 제출을 해보자.

![왜?](/uploads/4thpostimages/BJprob9012_Wrong1.jpg)
ㅋㅋ<br>
도대체 왜???????

사실 몇 번 실행을 시켜서 어느정도 맞는 걸 확인 후에 제출해도 틀리는 경우가 많아서 이번에도 큰 기대를 하진 않았었다.<br>그치만... 예제로도 확인해보고 내가 자체적으로도 몇 번 확인해봤는데...!! <br> 나의 막무가내식(?)알고리즘에 예외 케이스가 있었던걸까? 아니면 하나의 괄호 문자열의 길이에 대한 조건을 걸어주지 않아서 그랬을까?

한번 문자열에 대한 조건을 추가해보았다. if문으로 입력받은 문자열의 길이를 제한했다.
```cpp

...
 if (length >= 2 && length <= 50)  //여기 조건 추가!
 {
     int left[50], right[50];
     int l = 0, r = 0;

     //괄호 문자열 입력받기

     for (int j = 0; j < length; j++)
     {
         if (input[j] == ')')
         {
             right[r] = j;
             r++;
         }
         else if (input[j] == '(')
         {
             left[l] = j;
             l++;
         }
     }

     //VPS 판독
     if (l == r)
     {
         int flag = 0;

         for (int k = 0; k < l; k++)
         {
             if (right[k] < left[k])
             {
                 std::cout << "NO" << std::endl;
                 flag++;
                 break;
             }
         }
         if (flag == 0)
             std::cout << "YES" << std::endl;
     }
     else
         std::cout << "NO" << std::endl;

     delete[] input;

 }
...

```

그래도 틀렸다. 안되겠다 나와라 GPT!!

![gpt야도와줘](/uploads/4thpostimages/BJprob9012_Wrong1.jpg)

```
❌ 당신 코드에서 오답이 나올 수 있는 반례들
1. ())(
(: 2개, ): 2개 → 갯수 같음 → 당신 코드에선 일단 통과

인덱스: left = [0, 3], right = [1, 2]
→ right[0] = 1 < left[0] = 0이 아니므로, 통과
→ 하지만 닫는 괄호가 중간에 더 많이 나옴 → VPS 아님

✅ 정답: NO (❌ 당신 코드: YES)

2. (()())())
(: 4개, ): 5개 → 갯수 다름 → ✅ 당신 코드에서 NO 출력함

(통과되긴 하지만 잘못된 VPS → 정상 판별)

3. ())(()
(: 3개, ): 3개 → 갯수 같음 → 당신 코드에선 일단 통과

인덱스:

left = [0, 3, 4]

right = [1, 2, 5]

right[0] = 1, left[0] = 0 → ok

right[1] = 2, left[1] = 3 → ❌ (2 < 3 이므로 제대로 대응 안됨)
→ 당신 코드에서 걸러짐
→ ✅ 정답: NO (⭕️ 당신 코드에서도 NO 나올 수 있음)

그러나 이건 단순히 index 비교로 운 좋게 걸러지는 케이스일 뿐, 로직 자체가 올바르지 않음을 보여주는 반례가 아래와 같습니다.

4. ((()))())((
개수는 ( 5개, ) 5개 → 통과

left = [0, 1, 2, 7, 8], right = [3, 4, 5, 6, 9]

right[k] > left[k] 인 조건을 만족해버릴 수 있음

하지만 VPS 아님 → ❌ 당신 코드에서 틀릴 가능성 있음

5. (())())(()
(: 5개, ): 5개 → 개수 같음

실제로는 중간에 (())()) 부분이 틀려서 VPS 아님

✅ 정답: NO (❌ 당신 코드: YES 가능성 있음)
```
![바보gpt](\uploads/4thpostimages/BJprob9012_GPTbabo.jpg)
바보 GPT. 이렇게 된 거, 다른 사람들은 어떻게 풀었는지 참고해 보기로 했다. <br>보아하니 내가 작성한 코드는 스택의 활용과는 거리가 먼 것도 같다. 본인은 아직 템플릿의 사용을 제대로 익히지 않아 C 스타일에 좀 더 가깝게 푼 듯. C로 푼 사람들의 코드를 참고해 보니, 비슷하게 푼 것 같은데??
<br>
혹시, 동적할당 공간을 null character을 고려하지 않고 50으로 값을 주어서 그런걸까??! <br>
코드수정.

```cpp
#define _CRT_SECURE_NO_WARNINGS
#include <iostream>
#include <cstring>

int main()
{
    int trial;
    std::cin >> trial;

    for (int i = 0; i < trial; i++)
    {
        char* input = new char[51];  //char 공간을 50에서 51로 수정함
        std::cin >> input;
        int length = strlen(input);

        if (length >= 2 && length <= 50)
        {
            int left[50], right[50];
            int l = 0, r = 0;

            //괄호 문자열 입력받기
            for (int j = 0; j < length; j++)
            {
                if (input[j] == ')')
                {
                    right[r] = j;
                    r++;
                }
                else if (input[j] == '(')
                {
                    left[l] = j;
                    l++;
                }
            }

            //VPS 판독
            if (l == r)
            {
                int flag = 0;

                for (int k = 0; k < l; k++)
                {
                    if (right[k] < left[k])
                    {
                        std::cout << "NO" << std::endl;
                        flag++;
                        break;
                    }
                }
                if (flag == 0)
                    std::cout << "YES" << std::endl;
            }
            else
                std::cout << "NO" << std::endl;

            delete[] input;

        }
    }
}
```
(최종 코드입니다.)


ㅋㅋ<br>
그렇다<br>
메모리 공간을 충분히 주지 못한 나의 잘못이었다<br>
gpt도 잡지 못한 문제를 내가 찾아냈다<br>
gpt 진짜... 바보...
<br>
.
.
.
아무튼 이렇게 문제는 해결했지만, C++ 공부를 아직 마치지 않은 나로서 충분히 C++스럽게 문제를 풀진 못한듯. 추가적으로 공부한 내용이 있다면 좀 더 이어서 적어보도록 해야겠다.

